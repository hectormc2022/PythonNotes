Solución de problemas para la activación de anaconda navigator.

    conda update conda
    conda update anaconda-navigator
    anaconda-navigator --reset
    anaconda-navigator

Data types 
    int     numbers
    float   numbers with a decimal point
    str     Ordered sequence of characters "hello" 'Sammy' "2000"
    list    Ordered sequence of object  [10,"hello",200.3]
    dict    Unordered Key: Value pairs: {"mykey":"value", "name":"Frankie"}
    tup     Ordered immutable sequence of objects: (10,"hello",200.3)
    set     Unordered collection of unique objects: {"a","b"}
    bool    Logical value indicating True or False


Pyghon uses Dynamic Typing 
    my_dogs = 2

    my_dogs = ["Sammy" , "Frankie"]

These actions use [] square brackets and a number index to indicate positions of what you wish to gram.

Character       : h  e  l  l  o
Index           : 0  1  2  3  4
Reverse index   : 0 -4 -3 -2 -1 

Slicing allow you to grab a subsection of multiple characters, a "slice" of the string.
This has following syntax:
    [start:stop:step]

    mystring[abcdefghijk]
    mystring[2:]    - 'cdefghijk'
    mystring[:3]    - 'abc'
    mystring[3:6]   - 'def'
    mystring[::2]   - 'acegik'
    mystring[2:7:2] - 'ceg'
    mystring[::-1]  - 'kjihgfedcba'

Other way to perform this grap string.

    'Hello World'[2]
    'This is a test'[1:6]

There are multiple way to format string for printing variables in them. This is known as string interpolation.

print('Ths is a string {}'.format('INSERTED')
	- This is a string INSERTED

print('The {} {} {}'.format('fox','brown','quick'))
	- The fox brwon quick

print('The {2} {1} {0}'.format('fox','brown','quick'))
	- The quick brown fox

print('The {0} {0} {0}').format('fox','brown','quick'))
	- The fox fox fox

print('The {q} {b} {f}'.format(f='fox',b='brown',q='quick'))

Float formatting follows "{value:width.precision f}"

	- result = 100/777
	- 0.1287001287001287
	- print("The result was {r:1.2f}".format(r=result))
	- The result was 0.13

We can simplify the expresion format like this

name = "Jose"
print(f"Hello, this name is {name}")
	- Hello, this name is Jose

.append allows to add new element at end of list.


----------------------------------------------------------------------------------------------

Dictionaries: Objects retrieved by key name.
	Unordered and can not be sorted.

List: Object retrieved by location.
	Ordered Sequence can be indexed or sliced.


# Make a dictionary with {} and : to signify a key and a value
my_dict = {'key1':'value1','key2':'value2'}


my_dict = {'key1':123,'key2':[12,23,33],'key3':['item0','item1','item2']}

# Call values by their key
my_dict['key2']

Its important to note that dictionaries are very flexible in the data types they can hold. For example:

my_dict = {'key1':123,'key2':[12,23,33],'key3':['item0','item1','item2']}

# Can then even call methods on that value
my_dict['key3'][0].upper()

# Set the object equal to itself minus 123 
my_dict['key1'] -= 123
my_dict['key1']

---------------------------------------------------------------------------------------

Tuples
In Python tuples are very similar to lists, however, unlike lists they are immutable meaning they can not be changed. You would use tuples to present things that shouldn't be changed, such as days of the week, or dates on a calendar.


#Create a tuple
t = (1,2,3)

# Can also mix object types
t = ('one',2)

Immutability
It can't be stressed enough that tuples are immutable.


-----------------------------------------------------------------------------------------

Set and Booleans
There are two other object types in Python that we should quickly cover: Sets and Booleans.

Sets
Sets are an unordered collection of unique elements. We can construct them by using the set() function. Let's go ahead and make a set to see how it works.

x = set()


# We add to sets with the add() method
x.add(1)

# Add a different element
x.add(2)


# Create a list with repeats
list1 = [1,1,2,2,3,4,5,6,1,1]


# Cast as set to get unique values
set(list1)
{1, 2, 3, 4, 5, 6}


## --------------------- IF -----------------------
Indentation
It is important to keep a good understanding of how indentation works in Python to maintain the structure and order of your code. We will touch on this topic again when we start building out functions!

If statement

    if some_condition:
        # execute some code
    elif some_other_condition: 
        # do something different
    else:
        # do something else       
## -----------------------

x = False
if x:
    print('x was True!')
else:
    print('I will be printed in any case where x is not true')

## ----- Multiple Branches

loc = 'Bank'

if loc == 'Auto Shop':
    print('Welcome to the Auto Shop!')
elif loc == 'Bank':
    print('Welcome to the bank!')
else:
    print('Where are you?')

###

person = 'Sammy'

if person == 'Sammy':
    print('Welcome Sammy!')
else:
    print("Welcome, what's your name?")


## ------ For

my_iterable = [1,2,3]
for item_name in my_iterable:
    print(item_name)


for num in list1:
    print(num)


for num in list1:
    if num % 2 == 0:
        print(num)


for letter in 'This':
    print(letter)

T
h
i
s

## ------------- for with tuples

list2 = [(2,4),(6,8),(10,12)]

for tup in list2:
    print(tup)

(2, 4)
(6, 8)
(10, 12)

# Now with unpacking!
for (t1,t2) in list2:
    print(t1)

2
6
10

for (t1,t2) in list2:
    print(t1)
    ptint(t2)

2
4
6
8

## ------------- for with dictionaries

d = {'k1':1,'k2':2,'k3':3}

for item in d:
    print(item)

k1
k2
k3

dict_items([('k1', 1), ('k2', 2), ('k3', 3)])

for k,v in d.items():
    print(k) 
    print(v)

k1
1
k2
2
k3
3

list(d.keys())
    ['k1', 'k2', 'k3']
list(d.values())
    [1, 2, 3]


## ------ While loops


x = 0
while x < 10:
    print('x is currently: ',x)
    print(' x is still less than 10, adding 1 to x')
    x+=1

##---------------------------
